# Bisonc++
> eredeti minta fájlok: http://deva.web.elte.hu/fordprog/bisonc++.zip ,
> ez csak egy átdolgozása ennek a dokumentumnak: http://deva.web.elte.hu/fordprog/bisoncpp-tutorial.pdf
> még egy jegyzet: http://alumni.cs.ucr.edu/~lgao/teaching/bison.html

## Nyelvtanírás alapjai
- A kezdőszimbólum neve `start`
- A *terminálisok (tokenek) nagybetűsek*, a *nemterminálisok kisbetűsek*.
- A szabály bal- és jobb oldalát `:` választja el egymástól
- Az alternatívák között `|` szerepel.
- A szabályalternatívák sorozatát `;` zárja le.
- `C++` stílusú meg jegyzések írhatók a szabályokhoz.
- Az ε-t üres szabályjobb oldal valósítja meg, a gyakorlatban egy `//ures` megjegyzést szokás írni helyette.
- A jobb oldalak után `{` és `}` között `C++` kód írható, ami mindannyiszor végrehajtó dik, amikor az adott szabályt az elemző használja.
Ezekszerint: 

*S -> aC|C*

*C -> ε|bC*

nyelvtannak ez feletethető meg:
````Lex
start:
	A c
|
	c
;
````

````Lex
c:
	//ures
|
	B c
;
````


## 1

### Opciók
`%baseclass-preinclude <iostream>`
A generálandó osztályhierearchia ősosztályába beilleszti az iostream fej-állományt. Ez azokban a példákban lesz majd fontos, ahol a szabályokhoz csatolt akciókban írni akarunk a standard outputra.

### Tokenek
`%token ELEM NYITO CSUKO VESSZ`
A tokentípusokat a `%token` direktíva segítségével definiáljuk. A nyelvtan terminálisai az itt felsorolt négy elem, melyekből a `Bisonc++` az általa generálandó `Parser` osztályba egy felsorolási típust fog létrehozni.

> A nyelvtan egy zárójelbe tett, vesszővel elválasztott elemekből álló lista szintaxisát adja meg.

> __példa:__ `[ alma, barack, 42, szilva ]`

__Azaz a szabály__: 

 	*S -> NYITÓ lista CSUKÓ*
 	*lista -> ε|ELEM folytatás*
 	*folytatás -> ε|VESSZŐ ELEM folytatás*

fájl: `1/lista.y`


````Yacc
%baseclass-preinclude <iostream>

%token ELEM NYITO CSUKO VESSZO
%%

start:
	NYITO lista CSUKO
;

lista:
	// ures
|
	ELEM folytatas
;

folytatas:
	// ures
|
	VESSZO ELEM folytatas
;
````

---

### Hozzá tartozó Flex
Ez egy __`Flex` forrásfájl__, melyről részletes leírás itt található: http://deva.web.elte.hu/fordprog/flex-help.pdf A szintaktikus elemzés számára fontos részletek a következők:

`#include "Parserbase.h"`
Ezt a fejállományt a `Bisonc++` fogja generálni. Beillsztésével láthatóvá tesszük a `lista.y` fájlban megadott tokeneket

`return Parser::ELEM; `
Az egyes reguláris kifejezések sikeres illesztésekor a lexikális elemző vissza fog térni a megfelelő tokennel.

fájl: `1/lsita.l`

````Lex
%option noyywrap c++

%{
#include "Parserbase.h"
%}

BETU        [a-zA-Z]
SZAMJEGY    [0-9]
WS      [ \t\n]

%%

({BETU}|{SZAMJEGY})+    return Parser::ELEM;
","         return Parser::VESSZO;
"["         return Parser::NYITO;
"]"         return Parser::CSUKO;

{WS}+   // feher szokozok: semmi teendo

. {
    std::cerr << "lexikalis hiba" << std::endl;
    exit(1);
}

%%
````
---

### Hozzá tartozó C++
Ez a __`C++` forrás__ tartalmazza a `main` függvényt,amelyben ellenőrizzük a paranancssori argumentum meglétét és megpróbáljuk megnyitni a megadott fájlt. Ha ez sikeres, akkor ezzel az inputtal létrehozunk egy szintaktikus elemző objektumot(`pars`), melynek `parse()` metódusával indítjuk el az elemzést.

fájl: `1/lista.cc`

```C++
#include <iostream>
#include <fstream>
#include <sstream>
#include "Parser.h"
#include <FlexLexer.h>

using namespace std;

int main( int argc, char* argv[] )
{
	if( argc != 2 )
	{
		cerr << "Egy parancssori argumentum kell!" << endl;
		return 1;
	}
	ifstream in( argv[1] );
	if( !in )
	{
		cerr << "Nem tudom megnyitni: " << argv[1] << endl;
		return 1;
	}
	
	Parser pars(in);
	pars.parse();
	return 0;
}
````

### Fordítás 1
- `cd 1`
- `flex lista.l`
- `bisonc++ lista.y`
- ekkkor keletkezik: `Parserbase.h`,`Parser.ih`,`Parser.h`,`parse.cc`
- a `Parser.ih`,`Parser.h` nem kerül felülírásra legközelbb, így futtatható

### Parser.h
Ez a fejállomány definiálja a `Parser` osztályt. Ahhoz, hogy a szintaktikus elemző együtt tudjon működni a lexikális elemzővel, `include`-oljuk a `FlexLexer.h` fejállományt, felvesszük a lexikális elemzőt a Parser osztály adattagjai közé (`lexer`), és hozzáadunk az osztályhoz egy konstruktort, ami a kap ott bemeneti adatfolyammal inicializálja a `lexer`t. (Ezt a konstruktort hívtuk meg a `main` függvényben.)

fájl: `1/Parser.h`

````C++
// Generated by Bisonc++ V4.09.02 on Thu, 24 Sep 2015 17:14:55 +0200

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
#include "FlexLexer.h"
#include <cstdlib>


#undef Parser
class Parser: public ParserBase
{
        
    public:
        Parser( std::istream & in ) : lexer( &in, &std::cerr ) {}
        int parse();

    private:
        yyFlexLexer lexer;
        void error(char const *msg);    // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
        void exceptionHandler__(std::exception const &exc);
};


#endif
````

### Parser.ih
Ebben az __implementációs fejállományban__ az error tagfüggvény átírásával szabhatjuk testre a hibaüzeneteket. Ez a fejállomány definiálja továbbá a `Parser` osztály `lex()` függvényét: Valahányszora szintaktikus elemzőnek szüksége van a szöveg következő tokenjére, ezt a függvényt hívja meg. Ebben a példában ennek a függvénynek összesen annyi a teendője, hogy meghívja a `Parser` osztály adattag jai közé felvett lexikális elemző objektum `yylex()` metódusát,és a kapott eredményt adja vissza. Ez az eredmény az, amit a `Flex` forrásfájlban látható `return` utasítások adnak.

fájl: `1/Parser.ih`

````C++
// Generated by Bisonc++ V4.09.02 on Thu, 24 Sep 2015 17:14:55 +0200

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"


inline void Parser::error(char const *msg)
{
    std::cerr << msg << '\n';
}

// $insert lex
inline int Parser::lex()
{
    return lexer.yylex();
}

inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::exceptionHandler__(std::exception const &exc)         
{
    throw;              // re-implement to handle exceptions thrown by actions
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

//using namespace std;
````

### Fordítás 2
- `g++ -o lista lista.cclex.yy.cc parse.cc`
- a frodítás eredménye a `lista` futtatható állomány, a szintaktikus elemző
- `./lista jo.txt`
- `./lista hibas.txt`
Fordíthatunk ehelyett a `make` parancssal is, a `Makefile`t használva.


## 2
Az előzőhöz képest `2/jo.txt` és `2/hibas.txt` fájlok alapján kitalálható, hogy milyen nyelvet szeretnénk elemezni.

> __példa:__ `char betuje( string s, int index );`

__Azaz a szabály__: 

 	S -> deklaraciolista
 	deklaraciolista -> ε|deklaracio deklaraciolista
 	deklaracio -> AZONOSITO AZONOSITO parameterek PONTOSVESSZO
 	parameterek -> NYITO lista CSUKO
 	lista -> ε|AZONOSITO AZONOSITO folytatas
 	folytatas -> ε|VESSZO AZONOSITO AZONOSITO folytatas
 	AZONOSITO -> BETU BETU|BETU SZAMJEGY|"_"
 	VESSZO -> ","
	NYITO -> "("
	CSUKO -> ")"
	PONTOSVESSZO -> ";"
	BETU -> [a-zA-Z]
	SZAMJEGY -> [0-9]

Tehát a __terminálisok azaz a `%token`ek__ az `AZONOSITO`, `NYITO`, `CSUKO`, `VESSZO`, `PONTOSVESSZO`. Ezek kellenek a `.y` fájlba a *"nyilak"* jobb oldalára. A `BETU` és a `SZAMJEGY` ezek felépítéséhez kell, így azok a Flex, `.l` fájlban szerepelnek `makrók`ként.

Ezek alapján a `.y` fájlunk, az opciókkal így néz ki:
fájl: `2/fv.y`

````YACC
%baseclass-preinclude <iostream>
%token AZONOSITO NYITO CSUKO VESSZO PONTOSVESSZO
%%

start:
	deklaracioLista
;

deklaracioLista:
	// ures
|
	deklaracio deklaracioLista
;

deklaracio:
	AZONOSITO AZONOSITO parameterek PONTOSVESSZO
;

parameterek:
	NYITO lista CSUKO
;

lista:
	// ures
|
	AZONOSITO AZONOSITO folytatas
;

folytatas:
	// ures
|
	VESSZO AZONOSITO AZONOSITO folytatas
;
````
Az ehhez tartozó Lex ahol a szabályok "értelmezése" van:

fájl: `2/fv.l`

````LEX
%{
#include "Parserbase.h"
%}

BETU		[a-zA-Z]
SZAMJEGY	[0-9]
WS		[ \t\n]

%%

{BETU}({BETU}|{SZAMJEGY}|"_")*	return Parser::AZONOSITO;
","				return Parser::VESSZO;
"("				return Parser::NYITO;
")"				return Parser::CSUKO;
";"				return Parser::PONTOSVESSZO;

{WS}+	// feher szokozok: semmi teendo

. {
	std::cerr << "lexikalis hiba" << std::endl;
	return 0;
}
````
Ezek után a hozzá tartozó `C++` (`2/fv.cc`) fájlban ahogy az előbb is, ellenőrizzük a parancssori argumentumokat, és továbbadjuk őket a lexikális elemzőnek, az igazi munkát innen az __implementációs fejállomány__ (`2/Parser.ih`) végzi, innen tudja a szintaktikus elemző, hogy mi a szöveg következő tokenjével a teendője. Jelenleg elég azt "visszaköpni" így elég a `yylex()` függvényt meghívni.

----
### Hibakezelés

A `2-hibakezeles` könyvtár tartalma azt mutatja meg, hogyan lehet jobb hibaüzenetet adni szintaktikus hiba esetén illetve ilyen esetben is tovább folytatni az elemzést.

- A Flex forrásfájlban az `yylineno` opció segítségével gondoskodunk róla, hogy a lexikális elemző számlálja a sorokat.
- A `Parser.ih` fájlban a `lex` függvényben a `lineno` metódussal kérjük el a lexikális elemzőtől az aktuális sorszámot, és ezt a `Parser` osztály `d_loc__` adattagjának egyik mezőjébe mentjük el.
- A `Parser.ih` fájlban definiált `error` függvényt úgy módosítjuk, hogy felhasználja ezt a helyinformációt.
- Az `fl.y` fájl nyelvtani szabályait kibővítjük úgy, hogy használja a speciális error nemterminális szimbólumot. Ha az elemző szintaktikus hibát észlel, akkor megpróbálja illeszteni az `error`-t tartalmazó hibaalternatívákat. Vigyázni kell arra, hogy mindig egy jól meghatározott terminális zárja le ezeket a hibaalternatívákat, különben könnyen konfliktusokat okoznak a nyelvtanban.

## 3
Ez a példa a `begin` és `end` kulcsszavakkal __körbezárt blokkokból__ és `skip` kulcsszavakból álló nyelvet elemzi. Az üres fájl helyes, valamint `skip`-ek és blokkok tetszőleges sorozata is helyes. Egy blokkban szintén tetszőleges `skip` illetve blokk sorozat lehet, az üres blokkok is megngedettek. Éredemes ezt a példát a `jo.txt`-ben adott példa alapján gyakorlásként megoldani.

> __példa:__ 
`skip
begin
	skip
	skip
	begin
	end
	skip
end
begin
	begin
	end
end`

__Azaz a szabály__: 

 	S -> program
 	program -> ε|SKIP program|blokk program
 	blokk -> KEZDET program VEG
 	
	SKIP -> "skip"
 	KEZDET -> "begin"
 	VEG -> "end"
	
Ahogy az előbb, itt is, a szabályok első fele a `3/blokk.y` fájl része, a második a `3/blokk.l` fájl része. A többi nem kell érdekes dolgot végezzen, csak kiír, és ennyi.

## 4

Ez a példa a nulladrendű logikai formulákat képes elemezni. A formulák logikai literálokból, változókból és logikai összekeötő jelekből (negáció, konjunkció, 4 diszjunkció, implikáció, ekvivalancia) állnak. A nyelvtan nagyon egyszerű, a formulák megadása a következő sémát követi:
```YACC
formula:
IGAZ
...
formula VAGY formula
|
formula ES formula
;
```

__Ez a nyelvtan azonban nem egyértelmű!__ Példáu a `true & true & true`, vagy a `true & true | true` formulákhoz több különböző szintaxisfa is rajzolható. Ezek közül a helyes fát a logikai összekötő jelek bal- illetve jobbasszociativitása és a rájuk vonatkozó precedenciaszabályok határozzák meg. Ezeket az információkat a `Bisonc++` forrás(`4/logika.y`) elején adjuk meg a következő formában:
````C++
%right           EKV
%right           IMPL
%left            VAGY
%left            ES
%right           NEM
````
Ahol a `%right` és `%left` direktívák a __jobb- illetve balasszociativitást szabályozzák__, míg __a sorrend a precedenciát adja meg__ növekvő sorrendben. Ezt a technikát a beadandóban szereplő aritmetikai és logikai operátorok esetén is érdemes alkalmazni.

> __példa:__ 
fájl: `4/jo.txt`: 
`a & b <-> !(a -> !b)`

__Azaz a szabály__: 

 	S -> formula*
 	formula -> IGAZ|HAMIS|AZONOSITO|NYITO formula CSUKO|fomrula EKV formula|formula IMPL formula|formula VAGY formula|formula ES formula|NEM formula*
 	
	IGAZ -> "true"
 	HAMIS -> "false"
 	NYITO -> "("
	CSUKO -> ")"
	ES -> "&"
	VAGY -> "|"
	NEM -> "!"
	IMPL -> "->"
	EKV -> "<->"
	NYITO -> "("
	AZONOSITO -> BETU BETU|BETU SZAMJEGY
	
	BETU -> [a-zA-Z]
	SZAMJEGY -> [0-9]
Ahol mint eddig is, a szabályok első fele a `4/logika.y` fájlban találhatóak, a második fele a Flex fájl *reguláris kifejezések* részében, a `4/logika.l` fájl, míg a harmadik fele ugyanazon fájl *makrók*részében található.
